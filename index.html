<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>erratogram_demo</title>

<style>
  body { margin: 0; font-family: 'Noto Sans', system-ui, sans-serif; font-weight: 400; background-color: #141414;}
  .titlebox {
    font-size: 25px;
    background-color: #141414;
    color: #ddd; position: relative;
    border-top: 2px solid #ddd; padding-top: 5px; padding-bottom: 7px; padding-left: 10lvw; padding-right: 10lvw;}
    
  #editor {
    border-top: 2px solid #ddd;
    border-bottom: 2px solid #ddd;
    padding: 12px 10lvw;
    min-height: 400px; outline: none; line-height: 1.5;
    color: #ddd; font-size: 80px;
  }
  img.glyph {
    height: 1em;
    vertical-align: -0.1em;
    pointer-events: none;
    display: inline-block;
    margin: 0 .15em;
  }
  .hint { padding-left: 10lvw; color:#666; font-size: .9rem; margin-top:.5rem }

  .vertical-line {
    position: fixed;   /* 화면 고정 */
    top: 0;
    bottom: 0;         /* 위~아래 꽉 채움 */
    left: calc(10lvw - 8px);         /* 화면 정가운데 */
    width: 2px;        /* 두께 */
    background-color: #ddd; /* 선 색상 */
    z-index: 9999;     /* 다른 요소 위에 */
    pointer-events: none; /* 클릭 방해 안 하게 */
  }  
  
  .vertical-line2 {
    position: fixed;   /* 화면 고정 */
    top: 0;
    bottom: 0;         /* 위~아래 꽉 채움 */
    right: calc(10lvw - 8px);         /* 화면 정가운데 */
    width: 2px;        /* 두께 */
    background-color: #ddd; /* 선 색상 */
    z-index: 9999;     /* 다른 요소 위에 */
    pointer-events: none; /* 클릭 방해 안 하게 */
  }

</style>
</head>
<body>

<img src="./assets/symbol.svg" alt="symbol" style="width: 100px; display:block; margin: 50px auto;">
<div class="titlebox">make sentence</div>
<div id="editor" contenteditable="true" spellcheck="false" tabindex="0" inputmode="latin" autocapitalize="off" autocorrect="off"></div>

<div class="hint">english only</div>
<img src="./assets/logotype.svg" alt="logotype" style="width: 300px; display:block; margin: 70px auto;"></imgsrc>

<div class="vertical-line"></div>
<div class="vertical-line2"></div>

<script>
  const editor = document.getElementById("editor");

  const MAX_BY_LETTER = {
    a: 55, b: 61, c: 62, d: 58, e: 71, f: 27, g: 35, h: 57, i: 45,
    j: 32, k: 43, l: 39, m: 45, n: 90, o: 65, p: 55, q: 35, r: 90,
    s: 52, t: 54, u: 33, v: 37, w: 34, x: 21, y: 27, z: 22
  };
  const learnedMax = {};

  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function insertImgNodeAtRange(range, alt = "") {
    const img = document.createElement("img");
    img.className = "glyph";
    img.alt = alt;
    img.draggable = false;
    img.style.visibility = "hidden";
    range.deleteContents();
    range.insertNode(img);
    range.setStartAfter(img);
    range.collapse(true);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    return img;
  }

  function setSrcWithFallback(img, letter) {
    const knownMax = learnedMax[letter] ?? MAX_BY_LETTER[letter];
    const DEFAULT_MAX = 55;
    if (knownMax && knownMax > 0) {
      const n = randInt(1, knownMax);
      const src = `./assets/${letter}/${n}.svg`;
      img.onload = () => { img.style.visibility = "visible"; };
      img.onerror = () => { backwardProbe(img, letter, knownMax); };
      img.src = src;
      return;
    }
    backwardProbe(img, letter, DEFAULT_MAX);
  }

  function backwardProbe(img, letter, startMax) {
    let n = startMax;
    img.onload = () => {
      img.style.visibility = "visible";
      learnedMax[letter] = Math.max(learnedMax[letter] || 0, n);
    };
    img.onerror = () => {
      n -= 1;
      if (n >= 1) {
        img.src = `./assets/${letter}/${n}.svg`;
      } else {
        const parent = img.parentNode;
        if (parent) parent.removeChild(img);
      }
    };
    img.src = `./assets/${letter}/${n}.svg`;
  }

  let isComposing = false;

// IME 조합 상태 추적
editor.addEventListener("compositionstart", () => { isComposing = true; });
editor.addEventListener("compositionend",   () => { isComposing = false; });

// 1) 삭제(백스페이스)는 beforeinput 에서 확실히 처리
editor.addEventListener("beforeinput", (e) => {
  if (e.inputType === "deleteContentBackward") {
    const sel = window.getSelection();
    if (!sel.rangeCount) return;
    const range = sel.getRangeAt(0);

    let prev = null;
    if (range.startContainer.nodeType === Node.TEXT_NODE) {
      if (range.startOffset > 0) return; // 텍스트 중간이면 기본 삭제
      prev = range.startContainer.previousSibling;
    } else {
      const idx = range.startOffset - 1;
      prev = (idx >= 0) ? range.startContainer.childNodes[idx]
                        : range.startContainer.previousSibling;
    }

    if (prev && prev.nodeName === "IMG") {
      if (e.cancelable) e.preventDefault(); // 일부 브라우저는 cancelable 아닐 수 있음
      prev.remove();
    }
  }
}, { passive: false });

// 2) 입력은 모바일 호환을 위해 input 에서 마무리 치환
editor.addEventListener("input", () => {
  if (isComposing) return; // 조합 중엔 건너뜀

  const sel = window.getSelection();
  if (!sel.rangeCount) return;
  const range = sel.getRangeAt(0);

  // 캐럿 바로 앞의 "마지막 문자"를 찾아서 알파벳이면 IMG로 치환
  // (텍스트 노드/엘리먼트 노드 모두 대응)
  function getPrevNodeAndOffset(r) {
    if (r.startContainer.nodeType === Node.TEXT_NODE) {
      return { node: r.startContainer, offset: r.startOffset };
    }
    const idx = r.startOffset - 1;
    if (idx >= 0) {
      const n = r.startContainer.childNodes[idx];
      // 텍스트 노드면 끝 오프로, 이미지면 그대로, 요소면 그 요소의 마지막 텍스트를 더 탐색
      return { node: n, offset: (n && n.nodeType === Node.TEXT_NODE) ? n.nodeValue.length : null };
    } else {
      return { node: r.startContainer.previousSibling, offset: null };
    }
  }

  const { node, offset } = getPrevNodeAndOffset(range);
  if (!node) return;

  // case 1: 바로 앞이 텍스트 노드 -> 마지막 한 글자 확인
  if (node.nodeType === Node.TEXT_NODE) {
    const text = node.nodeValue || "";
    const pos = (typeof offset === "number") ? offset : text.length;
    if (pos <= 0) return;
    const lastChar = text.charAt(pos - 1);
    const ch = lastChar.toLowerCase();

    if (/^[a-z]$/.test(ch)) {
      // 마지막 문자 삭제
      node.nodeValue = text.slice(0, pos - 1) + text.slice(pos);

      // 캐럿 재설정: 삭제 위치로
      const sel2 = window.getSelection();
      const r2 = document.createRange();
      r2.setStart(node, pos - 1);
      r2.collapse(true);
      sel2.removeAllRanges();
      sel2.addRange(r2);

      // IMG 삽입
      const img = insertImgNodeAtRange(r2, ch);
      setSrcWithFallback(img, ch);
    }
    return;
  }

  // case 2: 바로 앞이 IMG면 그대로 둠 (이미 치환된 상태)
  if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === "IMG") {
    return;
  }

  // case 3: 요소 노드인 경우 그 안의 마지막 텍스트까지 탐색 (간단 처리 생략 가능)
  // 필요시 확장 가능
}, { passive: true });

// (선택) 데스크톱 단축키/화살표키는 OS 기본 동작 유지. keydown 은 굳이 안 써도 됩니다.

</script>
</body>
</html>
